<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="RunScaraAgent" Id="{1f4adf83-c440-4f87-8ce9-122caf9d3620}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK RunScaraAgent EXTENDS RunUnitGeneric
VAR_INPUT
	taskEngaged : BOOL;		//triggered by coordinator
	taskId : UINT;		//assigned by coordinator/internal 
END_VAR
VAR_OUTPUT
END_VAR
VAR		
	//-------------------
	// Remote control - Input
	//-------------------
	out_start_0 AT %Q* : BOOL;
	out_selProg1_1 AT%Q* : BOOL;
	out_selProg2_2 AT%Q* : BOOL;
	out_selProg4_3 AT%Q* : BOOL;
	
	out_stop_4 AT%Q* :BOOL; //foced stop, not recommend to use
	
	out_pause_5 AT%Q* : BOOL;		
	out_continue_6 AT%Q* : BOOL;
	
	out_reset_7 AT%Q* : BOOL; 	//error reset
	//-------------------
	// Remote control - Output
	//-------------------
	in_ready_0 AT%I* : BOOL; //Turns ON when the controller startup completes and no task is running. 
	in_running_1 AT%I* : BOOL; //Turns ON when task is running. However, turns OFF when “Paused output” is ON. 
	in_paused_2 AT%I* : BOOL; //
	in_error_3 AT%I* : BOOL;
	in_eStop_4 AT%I* : BOOL;		//as EDM
	in_safeGuard_5 AT%I* : BOOL;	//as EDM to safeguard
	in_sError_6 AT%I* : BOOL;
	in_warning_7 AT%I* : BOOL;
	//------------------
	//	User - input
	//------------------
	
	//------------------
	//	User - output 
	//------------------
	in_alarmCode AT%I* : WORD;
	out_alarmAck AT%Q* : WORD;
	
	out_stopReq AT%Q* : WORD;
	
	in_taskState AT%I* : WORD;
END_VAR
VAR CONSTANT
	taskInit : UINT := 1;
	taskAssembly : UINT :=2;
	taskSnipFit : UINT :=3;
	taskRegularCheck : UINT :=3;
	
	taskEngCalibration : UINT :=4;
	taskEngPickAndDrip : UINT:=5;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//mission:
//2. sequence start/stop as Remote I/O

//Select Program first then Start
//Stop program

//Pause program
//Continue when ready on

SUPER^();
THIS^.atomicOperation := TRUE; // the superior control agant should not be interrupted.

//----------------------
//	Task running control
//----------------------
IF bPause AND in_running_1 THEN
	out_pause_5 := TRUE;
ELSIF NOT bPause AND in_paused_2 THEN
	out_continue_6 := TRUE;
ELSE
	out_pause_5 := FALSE;
	out_continue_6 := FALSE;
END_IF

CASE outputState OF 
	eSpecialStates.INITIAL_BEGIN:
		//reset all signals , await SCARA comes into Ready State
		out_start_0 := FALSE;
		out_stop_4 := TRUE;
		out_pause_5 := FALSE;
		out_continue_6 := FALSE;
		bSerialTransition := TRUE;
	eSpecialStates.INITIAL_STATE_1:
		bSerialTransition := in_ready_0;
		IF bSerialTransition THEN 
			out_reset_7 := TRUE; //reset errors
			out_stop_4 := FALSE; //release
		END_IF
	eSpecialStates.INITIAL_STATE_2:
		//no error check
		IF NOT in_error_3 THEN
			out_reset_7:=FALSE;
			
			//initializing process activated
			taskId := taskInit;
			THIS^.ConvertTaskId();
			out_start_0 := TRUE;
		END_IF
	eSpecialStates.INITIAL_STATE_3:
		bSerialTransition := in_running_1;
	eSpecialStates.INITIAL_STATE_4:
		bSerialTransition := NOT in_running_1;
		IF bSerialTransition THEN
			out_start_0 := FALSE; //reset
			NextState := eSpecialStates.INITIAL_END;
		END_IF
	//-------------------------------
	// IDLE/Program selection states.
	//------------------------------
	eSpecialStates.GENERIC_GROUP_START:
		//--------------
		// Program selected and triggered
		//--------------
		bSerialTransition := taskEngaged;
		IF bSerialTransition THEN
			THIS^.ConvertTaskId();
			out_start_0 := TRUE;
		END_IF
	16#1:
		bSerialTransition := in_running_1;
		IF bSerialTransition THEN
			NextState := 16#200;
		END_IF
		//------------------------------------------------------------------
		// Operating
		//accept stop command only when programState in some specific state
		//------------------------------------------------------------------
	16#200:
		bSerialTransition := NOT in_running_1 OR NOT taskEngaged;
		IF  bSerialTransition THEN
			//task finished natually or request stop from coordinator
			out_stopReq := 1; //send request
		END_IF
	16#201:
		bSerialTransition := NOT in_running_1 AND in_ready_0;
		IF bSerialTransition THEN
			//succesfully stopped
			taskEngaged := FALSE;
			out_start_0 := FALSE;
			NextState := eSpecialStates.GENERIC_GROUP_START;
		END_IF	
END_CASE]]></ST>
    </Implementation>
    <Folder Name="CommonBase" Id="{8c2df53f-cc6d-4e3c-9b33-f2759249f7d5}" />
    <Method Name="ConfigureRead" Id="{0eacf177-2b75-49e1-b06a-5ff2158f3974}" FolderPath="CommonBase\">
      <Declaration><![CDATA[METHOD ConfigureRead : CellDataBlock
VAR_INPUT
	input : CellDataBlock; //would offer sub-index ...etc
	mode : eModes;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ConfigureWrite" Id="{ce7cfd7f-b9d8-4c0d-919e-2e8a95018cdd}" FolderPath="CommonBase\">
      <Declaration><![CDATA[METHOD ConfigureWrite : BOOL
VAR_INPUT
	input : CellDataBlock;
	mode : eModes;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Implemented by concre derived class
ConfigureWrite := true;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Control" Id="{6b8b504d-9bc1-4e63-aea6-7305b4d68d76}" FolderPath="CommonBase\">
      <Declaration><![CDATA[METHOD Control : BOOL
VAR_INPUT
	input : CellDataBlock;
	mode : eModes; //commit mode
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bEnStep := input.unit.base.controlWord.bit0EnStep;
bTrigStep := input.unit.base.controlWord.bit1TrigStep;
bPause := input.unit.base.controlWord.bit2StatePause;
bIsBypassed := input.unit.base.controlWord.bit3IsBypassed;
bWorkingOverride := input.unit.base.controlWord.bit4WorkingOverride;
bMaterialOverride := input.unit.base.controlWord.bit5MaterialOverride;
Control:=true;]]></ST>
      </Implementation>
    </Method>
    <Action Name="ConvertTaskId" Id="{def77aca-ea32-4716-b78e-8af443e3b063}">
      <Implementation>
        <ST><![CDATA[out_selProg1_1 := ((taskId AND 16#01) > 0);
out_selProg2_2 := ((taskId AND 16#02) > 0);
out_selProg4_3 := ((taskId AND 16#04) > 0);]]></ST>
      </Implementation>
    </Action>
    <Method Name="ErrorClear" Id="{f462e33e-113a-4bab-9083-d7f7df268290}" FolderPath="CommonBase\">
      <Declaration><![CDATA[METHOD ErrorClear : BOOL
VAR_INPUT
	input : eErrorClearWays;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[out_alarmAck := 0; // ack reset]]></ST>
      </Implementation>
    </Method>
    <Method Name="ErrorDetect" Id="{0d501c3c-1258-4947-b465-528162d76fdd}" FolderPath="CommonBase\">
      <Declaration><![CDATA[METHOD ErrorDetect : UDINT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ErrorDetect := in_alarmCode;

IF in_alarmCode <> 0 THEN
	out_alarmAck := in_alarmCode;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Monitor" Id="{bff2329b-af0a-4b0e-a719-df2270726c4b}" FolderPath="CommonBase\">
      <Declaration><![CDATA[METHOD Monitor : CellDataBlock
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Monitor.unit.base.controlWord.bit0EnStep := bEnStep;
Monitor.unit.base.controlWord.bit1TrigStep := bTrigStep;
Monitor.unit.base.controlWord.bit2StatePause := bPause;
Monitor.unit.base.controlWord.bit3IsBypassed := bIsBypassed;
Monitor.unit.base.controlWord.bit4WorkingOverride := bWorkingOverride;
Monitor.unit.base.controlWord.bit5MaterialOverride := bMaterialOverride;
//Transition status
Monitor.unit.base.transitionByte := transitionByte;
//
Monitor.unit.base.alarmCode := TO_WORD(AlarmCode);

//reflect task state instead
Monitor.unit.base.state := TO_WORD(THIS^.in_taskState);
Monitor.unit.base.nextState := TO_WORD(THIS^.in_taskState);

//
IF workingTimer.IN THEN
	//timer is running , reflect real value
	Monitor.unit.base.workingTimerCache := TO_DWORD(workingTimer.ET);
ELSE
	//timer is stopped , reflect cached value
	Monitor.unit.base.workingTimerCache := TO_DWORD(workingTimerCache);
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="TypeCode" Id="{64dae203-ab2b-41a6-88c7-848614dc4389}" FolderPath="CommonBase\">
      <Declaration><![CDATA[METHOD TypeCode : eCategrories
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TypeCode := eCategrories.SELECTION_UNIT;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RunScaraAgent">
      <LineId Id="3588" Count="90" />
      <LineId Id="437" Count="0" />
    </LineIds>
    <LineIds Name="RunScaraAgent.ConfigureRead">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunScaraAgent.ConfigureWrite">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="RunScaraAgent.Control">
      <LineId Id="5" Count="0" />
      <LineId Id="13" Count="2" />
      <LineId Id="27" Count="0" />
      <LineId Id="17" Count="1" />
    </LineIds>
    <LineIds Name="RunScaraAgent.ConvertTaskId">
      <LineId Id="2" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="RunScaraAgent.ErrorClear">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunScaraAgent.ErrorDetect">
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="11" Count="1" />
    </LineIds>
    <LineIds Name="RunScaraAgent.Monitor">
      <LineId Id="9" Count="4" />
      <LineId Id="5" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="18" Count="1" />
      <LineId Id="38" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="30" Count="2" />
      <LineId Id="28" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="RunScaraAgent.TypeCode">
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>