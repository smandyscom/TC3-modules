<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.10">
  <POU Name="RunUnitCellularC" Id="{0b9fe5c8-2bef-4f04-b3ac-e69748226c8f}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK RunUnitCellularC EXTENDS RunUnitTransporterBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	//devices
	reachSensor : POINTER TO RunSignal;
	interfereSensor : POINTER TO RunSignal;
	holderCylinder : POINTER TO RunCylinder;
	pusherCylinder : POINTER TO RunCylinder;
	//liner
	liner : POINTER TO RunAxis;
	ptLinerSend : POINTER TO ParameterSet;
	ptLinerWork : POINTER TO ParameterSet;
	ptLinerReceive : POINTER TO ParameterSet;
	//rotator
	rotator : POINTER TO RunAxis;
	ptRotatorMutual : POINTER TO ParameterSet;
	ptRotatorSend : POINTER TO ParameterSet;
	ptRotatorReceive : POINTER TO ParameterSet;
END_VAR
VAR PERSISTENT
	//TODO memorize carrier existed?
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[SUPER^();
//inherits sync/mat relative variables

//interfere auto cut axis	(high priority


CASE State OF 
	eSpecialStates.INITIAL_BEGIN:
		IF rotator^.ExecuteParameter(ptRotatorMutual) THEN
			NextState := eSpecialStates.INITIAL_END;
		END_IF	
	//-----------------switch function
	0:
		IF reachSensor^.debouncedOn THEN
			//occupied , sending procedure
			NextState := 16#2000;
		ELSE
			//vacuumed , receiving procedure
			NextState := 16#1000;
		END_IF
	//-----------------sending procedure 
	16#2000:
		IF NOT syncAcknowledged THEN
			bSerialTransition := TRUE; //make sure synchronized
		END_IF
	16#2001:
		IF holderCylinder^.Execute(eCylinderCommands.COMMAND_B) AND NOT transitionByte.0 THEN
			transitionByte.0 := TRUE;
		END_IF
		IF pusherCylinder^.Execute(eCylinderCommands.COMMAND_A) AND NOT transitionByte.1 THEN
			transitionByte.1 := TRUE;
		END_IF
		IF transitionByte = 16#3 AND interfereSensor^.debouncedOff THEN
			bSerialTransition := TRUE;
		END_IF
	16#2002:
		bSerialTransition := rotator^.ExecuteParameter(ptRotatorMutual); //otherwise would interfere
	16#2003:
		bSerialTransition := liner^.ExecuteParameter(ptLinerSend);
	16#2004:
		bSerialTransition := rotator^.ExecuteParameter(ptRotatorSend); //reached then rotate
	16#2005:
		IF holderCylinder^.Execute(eCylinderCommands.COMMAND_A) THEN
			//release , wait to send
			syncEngaged := TRUE;
			bSerialTransition := TRUE;
		END_IF
	16#2006:
		IF syncAcknowledged AND_THEN pusherCylinder^.Execute(eCylinderCommands.COMMAND_B) THEN
			//go out
			bSerialTransition := TRUE;
		END_IF
	16#2007:
		IF interfereSensor^.debouncedOff AND reachSensor^.debouncedOff THEN
			syncEngaged := FALSE;//leaved
			bSerialTransition := TRUE;
		END_IF
	16#2008:
		IF pusherCylinder^.Execute(eCylinderCommands.COMMAND_A) THEN
			NextState := 0; //rewind
		END_IF
	//---------------------receiving procedure
	16#1000:
		IF holderCylinder^.Execute(eCylinderCommands.COMMAND_A) AND NOT transitionByte.0 THEN
			transitionByte.0 := TRUE;
		END_IF
		IF pusherCylinder^.Execute(eCylinderCommands.COMMAND_A) AND NOT transitionByte.1 THEN
			transitionByte.1 := TRUE;
		END_IF
		IF transitionByte = 16#3 AND interfereSensor^.debouncedOff THEN
			bSerialTransition := TRUE;
		END_IF
	16#1001:
		bSerialTransition := rotator^.ExecuteParameter(ptRotatorMutual); //otherwise would interfere
	16#1002:
		bSerialTransition := liner^.ExecuteParameter(ptLinerReceive);
	16#1003:
		bSerialTransition := rotator^.ExecuteParameter(ptRotatorReceive); //reached then rotate
	16#1004:
		IF Upstream<>0 AND_THEN Upstream^.syncEngaged THEN
			Upstream^.syncAcknowledged := TRUE;
			bSerialTransition := TRUE;
		END_IF
	16#1005:
		IF Upstream<>0 AND_THEN NOT Upstream^.syncEngaged THEN
			Upstream^.syncAcknowledged := FALSE; //completely follow upstream ,
			bSerialTransition := TRUE;
		END_IF
	16#1006:
		bSerialTransition := holderCylinder^.Execute(eCylinderCommands.COMMAND_B);
	16#1007:
		IF interfereSensor^.debouncedOff AND reachSensor^.debouncedOn THEN
			NextState := 0;//rewind
		END_IF
END_CASE
]]></ST>
    </Implementation>
    <Method Name="FB_init" Id="{a9a51c1b-f758-4ded-9a6c-01bf50e17b39}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	argParent : POINTER TO RunUnitGeneric;
	argSlotBase : POINTER TO MaterialBlock;
	argSlotLast : POINTER TO MaterialBlock;
	
	argUpstream : POINTER TO RunUnitTransporterBase;
	
	argLiner : POINTER TO RunAxis;
	argRotator : POINTER TO RunAxis;
	argReachSensor : POINTER TO RunSignal;
	argInterfereSensor : POINTER TO RunSignal;
	argHolderCylinder : POINTER TO RunCylinder;
	argPusherCylinder : POINTER TO RunCylinder;
END_VAR
VAR CONSTANT
	indexSend : INT := 1;
	indexReceive : INT := 2;
	indexMutual : INT := 3; //equals to work position to Cellular D
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//initialize 
Parent := argParent;
SlotBase := argSlotBase;
SlotLast := argSlotLast;

Upstream := argUpstream;

IF Upstream=0 THEN
	isProxyMode:=TRUE; //no upstream , i am proxy
END_IF

//device link
liner := argLiner;
rotator := argRotator;
reachSensor := argReachSensor;
interfereSensor := argInterfereSensor;
holderCylinder := argHolderCylinder;
pusherCylinder := argPusherCylinder;
//position link
ptLinerSend := ADR(liner^.ptpCommands[indexSend]);
ptLinerReceive := ADR(liner^.ptpCommands[indexReceive]);
ptLinerWork := ADR(liner^.ptpCommands[indexMutual]);

ptRotatorSend := ADR(rotator^.ptpCommands[indexSend]);
ptRotatorReceive := ADR(rotator^.ptpCommands[indexReceive]);
ptRotatorMutual := ADR(rotator^.ptpCommands[indexMutual]);]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RunUnitCellularC">
      <LineId Id="26" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="171" Count="1" />
      <LineId Id="182" Count="1" />
      <LineId Id="42" Count="1" />
      <LineId Id="45" Count="1" />
      <LineId Id="146" Count="0" />
      <LineId Id="47" Count="1" />
      <LineId Id="147" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="88" Count="3" />
      <LineId Id="37" Count="0" />
      <LineId Id="109" Count="7" />
      <LineId Id="51" Count="0" />
      <LineId Id="184" Count="1" />
      <LineId Id="52" Count="0" />
      <LineId Id="186" Count="2" />
      <LineId Id="70" Count="2" />
      <LineId Id="74" Count="1" />
      <LineId Id="73" Count="0" />
      <LineId Id="76" Count="2" />
      <LineId Id="81" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="82" Count="1" />
      <LineId Id="86" Count="1" />
      <LineId Id="85" Count="0" />
      <LineId Id="95" Count="3" />
      <LineId Id="38" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="99" Count="1" />
      <LineId Id="92" Count="0" />
      <LineId Id="102" Count="1" />
      <LineId Id="101" Count="0" />
      <LineId Id="104" Count="2" />
      <LineId Id="192" Count="5" />
      <LineId Id="125" Count="2" />
      <LineId Id="129" Count="0" />
      <LineId Id="128" Count="0" />
      <LineId Id="130" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="208" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="199" Count="1" />
      <LineId Id="203" Count="1" />
      <LineId Id="207" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="27" Count="0" />
    </LineIds>
    <LineIds Name="RunUnitCellularC.FB_init">
      <LineId Id="21" Count="8" />
      <LineId Id="7" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="5" />
      <LineId Id="82" Count="3" />
      <LineId Id="88" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="86" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>