<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="RunUnitControllerV2" Id="{b8ed3dbb-ffb0-4792-8cf6-5dee6569b3ad}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK RunUnitControllerV2 EXTENDS RunGroupNode
VAR_INPUT
	isEmergency : BOOL; //would trigger initialize
	isManual : BOOL;
	
	requestInit : bool;
	requestErrorClear AT%M* : eErrorClearWays := eErrorClearWays.NO_ACTION;
END_VAR
VAR_OUTPUT
	//------------------------
	//	Error handling channel
	//------------------------
	
	errorType AT%Q* : eCategrories;
	errorIndex AT%Q* : DINT;
	errorCode AT%Q* : UDINT;
END_VAR
VAR		
	//error
	errorDevice : POINTER TO CommonBase := 0; //null reference
	
	
	errorDelayDetect : TON;	
	
	
END_VAR
VAR PERSISTENT
	axisUpperBound : INT;
	cylinderUpperBound : INT;
	signalUpperBound : INT;
	unitUpperBound : INT;
	slotUpperBound : int;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Purpose:
// 1. As abstract machine itself , switch between modes 
// 2. bridge signals to coordinator

//Clarify : 
// 1. Manual mode : component driven only
// 2. Semi-auto (PAUSE) : sequencer were driven, but most are forbidden to execute (PAUSE state)
// 3. Auto: sequencer drive , all drive autonomous

//Difference to V1 
//1. Hierarchy initializing

//----------------------------------------
// 	COMPONENT LEVEL:
//	running all devices/detect errors
//----------------------------------------
FOR nCounter :=1 TO axisUpperBound BY 1 DO
	gvl.axisControls[nCounter]();
	//error detection
	IF errorDevice=0 AND errorDelayDetect.Q AND gvl.axisControls[nCounter].ErrorDetect() <> 0 THEN
		//error scaned
		errorIndex := nCounter-1;
		errorDevice := ADR(gvl.axisControls[nCounter]);
	END_IF
END_FOR
FOR nCounter :=1 TO cylinderUpperBound BY 1 DO
	gvl.pnuematicControls[nCounter]^();
	//error detection
	IF errorDevice=0 AND errorDelayDetect.Q AND gvl.pnuematicControls[nCounter]^.ErrorDetect() <> 0 THEN
		//error scaned
		errorIndex := nCounter-1;
		errorDevice := gvl.pnuematicControls[nCounter];
	END_IF
END_FOR
FOR nCounter :=1 TO signalUpperBound BY 1 DO
	gvl.signalControls[nCounter]();
END_FOR
FOR nCounter :=1 TO unitUpperBound BY 1 DO
	//error detection
	IF errorDevice=0 AND errorDelayDetect.Q AND gvl.units[nCounter] <> 0 AND_THEN gvl.units[nCounter]^.ErrorDetect() <> 0THEN
		//station
		errorIndex := nCounter-1;
		errorDevice := gvl.units[nCounter];
	END_IF
END_FOR


//routines
errorDelayDetect(IN:= (errorDevice = 0), PT:= T#100MS, Q=> , ET=> );	//after reset , wait 100ms to detect
IF errorDevice <>0 THEN
	//error index had been specified
	errorType := errorDevice^.TypeCode();
	errorCode := errorDevice^.ErrorDetect();
	
	//reset error handling
	IF requestErrorClear <> eErrorClearWays.NO_ACTION THEN
		errorDevice^.ErrorClear(requestErrorClear); //call error clear function
		errorDevice := 0 ;// cut link
	END_IF
	
ELSE
	//reset
	errorType := 0;
	errorIndex := 0;
	errorCode := 0;
END_IF

//-------------------------------------------------
// START/STOP (internal pause due to process error
//-------------------------------------------------
IF errorDevice <>0 THEN
	bPause := TRUE; //forced stop
ELSE
	//leave current status
END_IF
//------------------------------------------------------------
//	IN MANUAL MODE, FORBIDEEN TO DRIVE SEQUENCES
//------------------------------------------------------------
IF NOT isManual THEN
	// sequences driven
	FOR nCounter :=1 TO unitUpperBound BY 1 DO
		IF gvl.units[nCounter] <> 0 THEN
			gvl.units[nCounter]^();
		END_IF
	END_FOR
END_IF

SUPER^(); //state machine driven
CASE outputState OF
	eSpecialStates.MAIN_WAIT_INITIALIZING:
		bSerialTransition := requestInit AND NOT isEmergency;
	eSpecialStates.MAIN_INITIALIZING:
		bSerialTransition := Initialize();
	eSpecialStates.MAIN_INITIALIZED:
		//wait emergency situation 
		IF isEmergency THEN
			NextState := eSpecialStates.MAIN_WAIT_INITIALIZING;
		END_IF
END_CASE

]]></ST>
    </Implementation>
    <Method Name="FB_init" Id="{59012378-cdc1-4f5d-9c82-ed2cdadc0d0a}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	argParent : POINTER TO RunUnitGeneric;
	argSlotBase : POINTER TO RunMaterial;
	argSlotLast : POINTER TO RunMaterial;
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//initialize 
Parent := argParent;
SlotBase := argSlotBase;
SlotLast := argSlotLast;
//
IF bInitRetains THEN
	NextState := eSpecialStates.INITIAL_BEGIN;
END_IF

state := eSpecialStates.MAIN_WAIT_INITIALIZING;
NextState:=state;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RunUnitControllerV2">
      <LineId Id="1605" Count="49" />
      <LineId Id="1731" Count="0" />
      <LineId Id="1656" Count="2" />
      <LineId Id="1734" Count="2" />
      <LineId Id="1738" Count="0" />
      <LineId Id="1732" Count="1" />
      <LineId Id="1660" Count="5" />
      <LineId Id="1745" Count="0" />
      <LineId Id="1744" Count="0" />
      <LineId Id="1669" Count="0" />
      <LineId Id="1758" Count="0" />
      <LineId Id="1739" Count="0" />
      <LineId Id="1743" Count="0" />
      <LineId Id="1759" Count="1" />
      <LineId Id="1741" Count="0" />
      <LineId Id="1693" Count="0" />
      <LineId Id="1800" Count="1" />
      <LineId Id="1694" Count="0" />
      <LineId Id="1753" Count="4" />
      <LineId Id="1747" Count="1" />
      <LineId Id="1702" Count="0" />
      <LineId Id="1705" Count="12" />
      <LineId Id="1050" Count="0" />
    </LineIds>
    <LineIds Name="RunUnitControllerV2.FB_init">
      <LineId Id="12" Count="7" />
      <LineId Id="43" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="79" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>