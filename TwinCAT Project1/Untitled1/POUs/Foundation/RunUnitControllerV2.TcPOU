<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="RunUnitControllerV2" Id="{b8ed3dbb-ffb0-4792-8cf6-5dee6569b3ad}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK RunUnitControllerV2 EXTENDS RunGroupNode
VAR_INPUT
	isEmergency : BOOL; //would trigger initialize , raise alarm
	isSafetyFault : BOOL;
	isAirIncorrect : BOOL;
	
	isManual : BOOL;
	
	requestInit : bool;
	requestErrorClear AT%M* : eErrorClearWays := eErrorClearWays.NO_ACTION;
	
	marshal : POINTER TO RunUnitGeneric;
END_VAR
VAR_OUTPUT
	//------------------------
	//	Error handling channel
	//------------------------	
	errorType AT%Q* : eCategrories;
	errorIndex AT%Q* : DINT;
	errorCode AT%Q* : UDINT;
END_VAR
VAR		
	//error
	errorDevice : POINTER TO CommonBase := 0; //null reference	
	errorDelayDetect : TON;	
END_VAR
VAR PERSISTENT
	axisUpperBound : INT;
	cylinderUpperBound : INT;
	signalUpperBound : INT;
	unitUpperBound : INT;
	slotUpperBound : int;
END_VAR
VAR CONSTANT
	ERR_EMG : DWORD :=1;
	ERR_INCORRECT_AIR : DWORD :=10;
	ERR_SAFETY : DWORD :=8501;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Purpose:
// 1. As abstract machine itself , switch between modes 
// 2. bridge signals to coordinator

//Clarify : 
// 1. Manual mode : component driven only
// 2. Semi-auto (PAUSE) : sequencer were driven, but most are forbidden to execute (PAUSE state)
// 3. Auto: sequencer drive , all drive autonomous

//Difference to V1 
//1. Hierarchy initializing

//---------------------------
//	System LEVEL
//---------------------------
IF isEmergency AND errorDevice=0 THEN
	//Emergency pressed
	errorDevice := THIS;
	THIS^.AlarmCode := ERR_EMG;
END_IF
IF isSafetyFault AND errorDevice=0 THEN
	//Safety
	errorDevice := THIS;
	THIS^.AlarmCode := ERR_SAFETY;
END_IF
IF isAirIncorrect AND errorDevice=0 THEN
	//Air supply
	errorDevice := THIS;
	THIS^.AlarmCode := ERR_INCORRECT_AIR;
END_IF
//----------------------------------------
// 	COMPONENT LEVEL:
//	running all devices/detect errors
//----------------------------------------
FOR nCounter :=1 TO axisUpperBound BY 1 DO
	gvl.axisControls[nCounter]();
	//error detection
	IF errorDevice=0 AND errorDelayDetect.Q AND gvl.axisControls[nCounter].ErrorDetect() <> 0 THEN
		//error scaned
		errorIndex := nCounter;
		errorDevice := ADR(gvl.axisControls[nCounter]);
	END_IF
END_FOR
FOR nCounter :=1 TO cylinderUpperBound BY 1 DO
	gvl.pnuematicControls[nCounter]^();
	//error detection
	IF errorDevice=0 AND errorDelayDetect.Q AND gvl.pnuematicControls[nCounter]^.ErrorDetect() <> 0 THEN
		//error scaned
		errorIndex := nCounter;
		errorDevice := gvl.pnuematicControls[nCounter];
	END_IF
END_FOR
FOR nCounter :=1 TO signalUpperBound BY 1 DO
	gvl.signalControls[nCounter]();
END_FOR
FOR nCounter :=1 TO unitUpperBound BY 1 DO
	//error detection
	IF errorDevice=0 AND errorDelayDetect.Q AND gvl.units[nCounter] <> 0 AND_THEN gvl.units[nCounter]^.ErrorDetect() <> 0THEN
		//station
		errorIndex := nCounter;
		errorDevice := gvl.units[nCounter];
	END_IF
END_FOR


//routines
errorDelayDetect(IN:= (errorDevice = 0), PT:= T#100MS, Q=> , ET=> );	//after reset , wait 100ms to detect
IF errorDevice <>0 THEN
	//error index had been specified
	errorType := errorDevice^.TypeCode();
	errorCode := errorDevice^.ErrorDetect();
	
	//reset error handling
	IF requestErrorClear <> eErrorClearWays.NO_ACTION THEN
		errorDevice^.ErrorClear(requestErrorClear); //call error clear function
		errorDevice := 0 ;// cut link
	END_IF
	
ELSE
	//reset
	errorType := 0;
	errorIndex := 0;
	errorCode := 0;
END_IF

//-------------------------------------------------
// START/STOP (internal pause due to process error
//-------------------------------------------------
IF errorDevice <>0 THEN
	bPause := TRUE; //forced stop
ELSE
	//leave current status
END_IF
//------------------------------------------------------------
//	IN MANUAL MODE, FORBIDEEN TO DRIVE SEQUENCES
//------------------------------------------------------------
IF NOT isManual THEN
	// sequences driven
	FOR nCounter :=1 TO unitUpperBound BY 1 DO
		IF gvl.units[nCounter] <> 0 THEN
			gvl.units[nCounter]^();
		END_IF
	END_FOR
END_IF

SUPER^(); //state machine driven
CASE outputState OF
	eSpecialStates.MAIN_WAIT_INITIALIZING:
		bSerialTransition := requestInit AND NOT isEmergency;
	eSpecialStates.MAIN_INITIALIZING:
		bSerialTransition := marshal<>0 AND_THEN marshal^.Initialize();
		IF bSerialTransition THEN
			marshal^.NextState := eSpecialStates.GENERIC_GROUP_START;
		END_IF
	eSpecialStates.MAIN_INITIALIZED:
		//wait emergency situation 
		IF isEmergency OR requestInit THEN
			NextState := eSpecialStates.MAIN_WAIT_INITIALIZING;
		END_IF
END_CASE

]]></ST>
    </Implementation>
    <Method Name="FB_init" Id="{59012378-cdc1-4f5d-9c82-ed2cdadc0d0a}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	argParent : POINTER TO RunUnitGeneric;
	argSlotBase : POINTER TO RunMaterial;
	argSlotLast : POINTER TO RunMaterial;
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//initialize 
Parent := argParent;
SlotBase := argSlotBase;
SlotLast := argSlotLast;
//
IF bInitRetains THEN
	NextState := eSpecialStates.INITIAL_BEGIN;
END_IF

state := eSpecialStates.MAIN_INITIALIZING; //as beginning
NextState:=state;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RunUnitControllerV2">
      <LineId Id="1605" Count="10" />
      <LineId Id="1865" Count="3" />
      <LineId Id="1903" Count="0" />
      <LineId Id="1910" Count="0" />
      <LineId Id="1905" Count="1" />
      <LineId Id="1904" Count="0" />
      <LineId Id="1915" Count="0" />
      <LineId Id="1923" Count="1" />
      <LineId Id="1916" Count="1" />
      <LineId Id="1921" Count="0" />
      <LineId Id="1925" Count="1" />
      <LineId Id="1922" Count="0" />
      <LineId Id="1920" Count="0" />
      <LineId Id="1617" Count="37" />
      <LineId Id="1731" Count="0" />
      <LineId Id="1656" Count="2" />
      <LineId Id="1734" Count="2" />
      <LineId Id="1738" Count="0" />
      <LineId Id="1732" Count="1" />
      <LineId Id="1660" Count="5" />
      <LineId Id="1745" Count="0" />
      <LineId Id="1744" Count="0" />
      <LineId Id="1669" Count="0" />
      <LineId Id="1758" Count="0" />
      <LineId Id="1739" Count="0" />
      <LineId Id="1743" Count="0" />
      <LineId Id="1759" Count="1" />
      <LineId Id="1741" Count="0" />
      <LineId Id="1693" Count="0" />
      <LineId Id="1800" Count="1" />
      <LineId Id="1694" Count="0" />
      <LineId Id="1753" Count="4" />
      <LineId Id="1747" Count="1" />
      <LineId Id="1702" Count="0" />
      <LineId Id="1705" Count="5" />
      <LineId Id="1832" Count="2" />
      <LineId Id="1711" Count="6" />
      <LineId Id="1050" Count="0" />
    </LineIds>
    <LineIds Name="RunUnitControllerV2.FB_init">
      <LineId Id="12" Count="7" />
      <LineId Id="43" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="79" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>