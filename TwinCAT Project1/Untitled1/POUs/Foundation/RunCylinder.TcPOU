<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.10">
  <POU Name="RunCylinder" Id="{a99bf5d1-aaa3-4095-9742-005d9ab3fed8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK RunCylinder
VAR			
	A_SENSOR_USED_COUNT : INT := 0;
	B_SENSOR_USED_COUNT : INT :=0 ;	

	COMMAND_CACHED : eCylinderCommands; //1 , HMI->PLC
	LAST_COMMAND : eCylinderCommands;   //2 , 
		
	ACT_A AT %Q* : ARRAY[1..2] OF BOOL;
	ACT_B AT %Q* : ARRAY[1..2] OF BOOL;
	
	SENSOR_A AT %I* : ARRAY[1..4] OF BOOL;
	SENSOR_B AT %I* : ARRAY[1..4] OF BOOL;

	nCounter : INT := 0;
	bMatched : BOOL := false;
	
	TMR_WATCH_DOG : TON ; //Watch dog timer
	TMR_DELAY_TO_A : TON;
	TMR_DELAY_TO_B : TON;
	
	BIT_WARNING : BIT; //0
	BIT_A_MATCH : BIT; //1
	BIT_B_MATCH : BIT; //2
	BIT_WARN_SUPPRESS : BIT; //3 , (Control)
	
	BIT_DONE : BIT; //5
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Run timers
TMR_WATCH_DOG(IN:= , PT:= , Q=> , ET=> );
TMR_DELAY_TO_A(IN:= , PT:= , Q=> , ET=> );
TMR_DELAY_TO_B(IN:= , PT:= , Q=> , ET=> );

// scan all sensor status
BIT_A_MATCH := TRUE;
FOR nCounter := 1 TO A_SENSOR_USED_COUNT BY 1 DO
	BIT_A_MATCH := (BIT_A_MATCH AND SENSOR_A[nCounter]);
END_FOR
BIT_B_MATCH := TRUE;
FOR nCounter := 1 TO B_SENSOR_USED_COUNT BY 1 DO
	BIT_B_MATCH := (BIT_B_MATCH AND SENSOR_B[nCounter]);
END_FOR

// if watch dog had been reset due to command changed in previous scan
// restart
IF NOT TMR_WATCH_DOG.IN THEN
	TMR_WATCH_DOG.IN := TRUE;
END_IF

// once command changes , reset timer counter
IF COMMAND_CACHED <> LAST_COMMAND THEN
	//ptBlock^.TMR_WATCH_DOG.IN:=false;	//invalid , do not across a scan
	TMR_WATCH_DOG.IN:=FALSE;
	TMR_DELAY_TO_A.IN := (COMMAND_CACHED=eCylinderCommands.COMMAND_A); //active A delay timer
	TMR_DELAY_TO_B.IN := (COMMAND_CACHED=eCylinderCommands.COMMAND_B); //if no sensor B , active B delay timer
	
	//reset done/warn
	BIT_DONE := FALSE;
	BIT_WARNING := FALSE;
	
	//output process
	FOR nCounter:=1 TO 2 BY 1 DO
		ACT_A[nCounter] := (COMMAND_CACHED = eCylinderCommands.COMMAND_A);
		ACT_B[nCounter] := (COMMAND_CACHED = eCylinderCommands.COMMAND_B);
	END_FOR
	
END_IF


//reset
bMatched := FALSE;
// Check if match
CASE COMMAND_CACHED OF
	eCylinderCommands.NO_COMMAND:
	bMatched:= TRUE;
	
	eCylinderCommands.COMMAND_A:
	IF TMR_DELAY_TO_A.Q THEN
		bMatched:= (BIT_A_MATCH ) AND (NOT BIT_B_MATCH OR B_SENSOR_USED_COUNT=0);
	END_IF
	
	eCylinderCommands.COMMAND_B:
	IF TMR_DELAY_TO_B.Q THEN
		bMatched:= (NOT BIT_A_MATCH OR A_SENSOR_USED_COUNT=0) AND (BIT_B_MATCH );
	END_IF
		
END_CASE

// status update
BIT_DONE := bMatched OR (NOT bMatched AND BIT_WARN_SUPPRESS AND TMR_WATCH_DOG.Q);
BIT_WARNING := NOT bMatched AND NOT BIT_WARN_SUPPRESS AND TMR_WATCH_DOG.Q;


// cache last command
LAST_COMMAND := COMMAND_CACHED;


//scan-out status
//comm.STATUS_WORD.0 := BIT_WARNING;
//comm.STATUS_WORD.1 := BIT_A_MATCH;
//comm.STATUS_WORD.2 := BIT_B_MATCH;
//comm.STATUS_WORD.5 := BIT_DONE;]]></ST>
    </Implementation>
    <Method Name="Execute" Id="{13693201-8c27-444e-bbfc-9d5e6a727077}">
      <Declaration><![CDATA[METHOD Execute : BOOL
VAR_INPUT
	argCommand : eCylinderCommands;
END_VAR
VAR
	outDone : BOOL ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// store command
COMMAND_CACHED := argCommand;

outDone := BIT_DONE AND NOT BIT_WARNING AND (COMMAND_CACHED = LAST_COMMAND);

//reset surpress
IF outDone THEN
	BIT_WARN_SUPPRESS := FALSE;
END_IF

Execute:=outDone; //return]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{41827ab5-0173-413a-8bd3-19090e017f80}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	//argASensorUsed : INT := 0;
	//argBSensorUsed : INT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//A_SENSOR_USED_COUNT := argASensorUsed;
//B_SENSOR_USED_COUNT := argBSensorUsed;

//given timer initial value
//TMR_WATCH_DOG.PT := T#200MS;
//TMR_DELAY_TO_A.PT := T#200MS;
//TMR_DELAY_TO_B.PT := T#200MS;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RunCylinder">
      <LineId Id="144" Count="66" />
      <LineId Id="233" Count="5" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.Execute">
      <LineId Id="9" Count="9" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.FB_init">
      <LineId Id="20" Count="1" />
      <LineId Id="14" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="15" Count="2" />
    </LineIds>
  </POU>
</TcPlcObject>