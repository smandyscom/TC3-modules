<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.10">
  <POU Name="RunCylinder" Id="{a99bf5d1-aaa3-4095-9742-005d9ab3fed8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK RunCylinder IMPLEMENTS ICommon
VAR			

	COMMAND_CACHED : eCylinderCommands; //1 , HMI->PLC
	LAST_COMMAND : eCylinderCommands;   //2 , 
		
	ACT_A AT %Q* : ARRAY[1..2] OF BOOL;
	ACT_B AT %Q* : ARRAY[1..2] OF BOOL;
	
	SENSOR_A AT %I* : ARRAY[1..4] OF BOOL;
	SENSOR_B AT %I* : ARRAY[1..4] OF BOOL;

	nCounter : INT := 0;
	bMatched : BOOL := false;
		
	BIT_WARNING : BIT; //0
	BIT_A_MATCH : BIT; //1
	BIT_B_MATCH : BIT; //2
	BIT_WARN_SUPPRESS : BIT; //3 , (Control)
	
	BIT_DONE : BIT; //5
	
END_VAR
VAR RETAIN
	A_SENSOR_USED_COUNT : INT := 0;
	B_SENSOR_USED_COUNT : INT :=0 ;		

	TMR_WATCH_DOG : TON ; //Watch dog timer
	TMR_DELAY_TO_A : TON;
	TMR_DELAY_TO_B : TON;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Run timers
TMR_WATCH_DOG(IN:= , PT:= , Q=> , ET=> );
TMR_DELAY_TO_A(IN:= , PT:= , Q=> , ET=> );
TMR_DELAY_TO_B(IN:= , PT:= , Q=> , ET=> );

// scan all sensor status
BIT_A_MATCH := TRUE;
FOR nCounter := 1 TO A_SENSOR_USED_COUNT BY 1 DO
	BIT_A_MATCH := (BIT_A_MATCH AND SENSOR_A[nCounter]);
END_FOR
BIT_B_MATCH := TRUE;
FOR nCounter := 1 TO B_SENSOR_USED_COUNT BY 1 DO
	BIT_B_MATCH := (BIT_B_MATCH AND SENSOR_B[nCounter]);
END_FOR

// if watch dog had been reset due to command changed in previous scan
// restart
IF NOT TMR_WATCH_DOG.IN THEN
	TMR_WATCH_DOG.IN := TRUE;
END_IF

// once command changes , reset timer counter
IF COMMAND_CACHED <> LAST_COMMAND THEN
	//ptBlock^.TMR_WATCH_DOG.IN:=false;	//invalid , do not across a scan
	TMR_WATCH_DOG.IN:=FALSE;
	TMR_DELAY_TO_A.IN := (COMMAND_CACHED=eCylinderCommands.COMMAND_A); //active A delay timer
	TMR_DELAY_TO_B.IN := (COMMAND_CACHED=eCylinderCommands.COMMAND_B); //if no sensor B , active B delay timer
	
	//reset done/warn
	BIT_DONE := FALSE;
	BIT_WARNING := FALSE;
	
	//output process
	FOR nCounter:=1 TO 2 BY 1 DO
		ACT_A[nCounter] := (COMMAND_CACHED = eCylinderCommands.COMMAND_A);
		ACT_B[nCounter] := (COMMAND_CACHED = eCylinderCommands.COMMAND_B);
	END_FOR
	
END_IF


//reset
bMatched := FALSE;
// Check if match
CASE COMMAND_CACHED OF
	eCylinderCommands.NO_COMMAND:
	bMatched:= TRUE;
	
	eCylinderCommands.COMMAND_A:
	IF TMR_DELAY_TO_A.Q THEN
		bMatched:= (BIT_A_MATCH ) AND (NOT BIT_B_MATCH OR B_SENSOR_USED_COUNT=0);
	END_IF
	
	eCylinderCommands.COMMAND_B:
	IF TMR_DELAY_TO_B.Q THEN
		bMatched:= (NOT BIT_A_MATCH OR A_SENSOR_USED_COUNT=0) AND (BIT_B_MATCH );
	END_IF
		
END_CASE

// status update
BIT_DONE := bMatched OR (NOT bMatched AND BIT_WARN_SUPPRESS AND TMR_WATCH_DOG.Q);
BIT_WARNING := NOT bMatched AND NOT BIT_WARN_SUPPRESS AND TMR_WATCH_DOG.Q;


// cache last command
LAST_COMMAND := COMMAND_CACHED;


//scan-out status
//comm.STATUS_WORD.0 := BIT_WARNING;
//comm.STATUS_WORD.1 := BIT_A_MATCH;
//comm.STATUS_WORD.2 := BIT_B_MATCH;
//comm.STATUS_WORD.5 := BIT_DONE;]]></ST>
    </Implementation>
    <Folder Name="ICommon" Id="{48bea1d3-0a28-439a-92dd-8f8417445059}" />
    <Method Name="ConfigureRead" Id="{bc98ac9f-d51a-43ad-b528-a1a54fe67ea0}" FolderPath="ICommon\">
      <Declaration><![CDATA[METHOD ConfigureRead : Block64Words
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ConfigureWrite" Id="{f3b24b0b-d22d-4018-b1c9-709a957955d9}" FolderPath="ICommon\">
      <Declaration><![CDATA[METHOD ConfigureWrite : BOOL
VAR_INPUT
	input : Block64Words;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="Control" Id="{57e57159-f3d2-45e6-85f3-9a286c6e359d}" FolderPath="ICommon\">
      <Declaration><![CDATA[METHOD Control : BOOL
VAR_INPUT
	input : Block64Words;
	mode : int;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ErrorClear" Id="{945c9ccd-86db-44c6-8d20-e9e7b141f3bf}" FolderPath="ICommon\">
      <Declaration><![CDATA[METHOD ErrorClear : BOOL
VAR_INPUT
	input : eErrorClearWays;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ErrorDetect" Id="{6a0ed216-b71b-4070-ba95-2d84d65ddbd3}" FolderPath="ICommon\">
      <Declaration><![CDATA[METHOD ErrorDetect : INT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="Execute" Id="{13693201-8c27-444e-bbfc-9d5e6a727077}">
      <Declaration><![CDATA[METHOD Execute : BOOL
VAR_INPUT
	argCommand : eCylinderCommands;
END_VAR
VAR
	outDone : BOOL ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// store command
COMMAND_CACHED := argCommand;

outDone := BIT_DONE AND NOT BIT_WARNING AND (COMMAND_CACHED = LAST_COMMAND);

//reset surpress
IF outDone THEN
	BIT_WARN_SUPPRESS := FALSE;
END_IF

Execute:=outDone; //return]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{41827ab5-0173-413a-8bd3-19090e017f80}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	//argASensorUsed : INT := 0;
	//argBSensorUsed : INT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//A_SENSOR_USED_COUNT := argASensorUsed;
//B_SENSOR_USED_COUNT := argBSensorUsed;

//given timer initial value
//TMR_WATCH_DOG.PT := T#200MS;
//TMR_DELAY_TO_A.PT := T#200MS;
//TMR_DELAY_TO_B.PT := T#200MS;
IF bInitRetains THEN
	TMR_WATCH_DOG.PT := T#200MS;
	TMR_DELAY_TO_A.PT := T#200MS;
	TMR_DELAY_TO_B.PT := T#200MS;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Monitor" Id="{120aac0f-3608-4cae-b6d2-bb459b1d4cf7}" FolderPath="ICommon\">
      <Declaration><![CDATA[METHOD Monitor : Block64Words
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="TypeCode" Id="{2fbd4fdf-fcb0-4d45-95f6-2e5788341375}" FolderPath="ICommon\">
      <Declaration><![CDATA[METHOD TypeCode : eTypeCodes
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RunCylinder">
      <LineId Id="144" Count="66" />
      <LineId Id="233" Count="5" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.ConfigureRead">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.ConfigureWrite">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.Control">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.ErrorClear">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.ErrorDetect">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.Execute">
      <LineId Id="9" Count="9" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.FB_init">
      <LineId Id="20" Count="1" />
      <LineId Id="14" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="15" Count="2" />
      <LineId Id="30" Count="1" />
      <LineId Id="33" Count="1" />
      <LineId Id="32" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.Monitor">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RunCylinder.TypeCode">
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>